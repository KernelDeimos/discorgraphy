const MY_NAME = 'tools/generate.js';

const fs = require('fs');
const path = require('path');
const yaml = require('yaml');

const PROJECT_ROOT = path.join(__dirname, '..');
const IGNORE_LIST = ['node_modules', '.git'];

const generators = [];

// GENERATE types.ts
generators.push({
    scope: 'bindings',
    fn: (path, bindings) => {
        let types = bindings.map(v => v.symbol)
        let src = `// GENERATED by ${MY_NAME}\n`;
        src += `export const TYPES = {\n` + (types || [])
            .map(v => `    ${v}: Symbol('${v}'),`)
            .join('\n') + '\n};\n';
        return [
            ['types.ts', src],
        ];
    },
});

// GENERATE inversify.config.ts
generators.push({
    scope: 'bindings',
    fn: (path, bindings) => {
        let types = bindings.map(v => v.symbol)
        let src = `// GENERATED by ${MY_NAME}\n`;
        src += 'import "reflect-metadata";\n';

        let requires = {};
        for ( let binding of bindings ) {
            if ( ! binding.args ) continue;
            for ( let k in binding.args ) {
                let val = binding.args[k];
                if ( ! Array.isArray(val) ) continue;
                let importFile = val[0];
                let importName = val[1];
                if ( ! requires[importFile] ) requires[importFile] = {};
                requires[importFile][importName] = true;
            }
        }
        for ( let binding of bindings ) {
            if ( ! binding.constnat ) continue;
            if ( ! Array.isArray(binding.constnat) ) continue;
            let importFile = binding.constant[0];
            let importName = binding.constant[1];
            if ( ! requires[importFile] ) requires[importFile] = {}; // TODO: DRY
            requires[importFile][importName] = true;
        }

        src += [
            `import { Container } from "inversify";`,
            `import { TYPES } from "./types";`,
        ].join('\n') + '\n';
        src += '\n';

        for ( let binding of bindings ) {
            if ( ! binding.module ) {
                binding.type = typeof binding.value;
                continue;
            }
            binding.type = binding.symbol;
            src += `import { ${binding.symbol} } from "${binding.module}";\n`
        }
        src += '\n';

        for ( let importFile in requires ) {
            src += `import { ${Object.keys(requires[importFile]).join(', ')} } ` +
                `from "${importFile}";\n`;
        }
        src += '\n';

        src += 'const container = new Container();\n';
        src += '\n';

        for ( let binding of bindings ) {
            // TODO: allow interfaces here
            src += `container.bind<${binding.type}>(TYPES.${binding.symbol})`;
            let resolveArg = argSpec => Array.isArray(argSpec) ? argSpec[1] : argSpec;
            console.log('cons', binding.args)
            if ( binding.args ) {
                let args = '';
                if ( Array.isArray(binding.args) ) {
                    args += binding.args.map(arg => resolveArg(arg)).join(', ');
                } else {
                    args += `{ ` + Object.keys(binding.args)
                        .map(k => `${k}: ${resolveArg(binding.args[k])}`)
                        .join(', ') + ` }`;
                }
                src += `\n\t.toConstantValue(new ${binding.symbol}(${args}))`;
            } else if ( binding.value !== undefined ) {
                src += `\n\t.toConstantValue(${JSON.stringify(binding.value)})`;
            } else {
                src += `.to(${binding.symbol})`
            }
            src += `;\n`;
        }
        src += '\n';

        src += [
            `export { container };`
        ].join('\n') + '\n';

        return [
            ['inversify.config.ts', src],
        ];
    },
});

async function* walk(dir, searchFile) {
    for await ( const node of await fs.promises.opendir(dir) ) {
        const fullPath = path.join(dir, node.name);
        if ( node.isDirectory() && ! IGNORE_LIST.includes(node.name) ) {
            yield* walk(fullPath, searchFile);
        }
        else if ( node.isFile() && node.name == searchFile ) {
            yield dir;
        }
    }
}

async function main() {
    for await (const p of walk(PROJECT_ROOT, 'models.yml')) {
        let ymlSource = await fs.promises.readFile(path.join(p, 'models.yml'));
        let models = yaml.parse(ymlSource.toString('utf-8'));

        for ( let generator of generators ) {
            // ???: dotted scope support
            if ( ! models[generator.scope] ) continue;

            let data = models[generator.scope];
            console.log('models', `[${generator.scope}] =`, data)
            let outFiles = generator.fn(p, data);
            for ( let outFile of outFiles ) {
                await fs.promises.writeFile(
                    path.join(p, outFile[0]),
                    outFile[1],
                )
            }
        }

    }
}

main();